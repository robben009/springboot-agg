package arrayType;

/**
 * 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
 * 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。
 */
public class 买卖股票的最佳时机 {
    public static int maxProfit(int[] prices) {
        if (prices.length < 2) {
            return 0; // 如果价格数组少于 2 天，则无法进行交易
        }

        int n = prices.length;
        int[][] dp = new int[n][2]; // dp[i][0] 表示第 i 天不持有股票的最大利润，dp[i][1] 表示第 i 天持有股票的最大利润

        // 初始化
        dp[0][0] = 0; // 第 0 天不持有股票，利润为 0
        dp[0][1] = -prices[0]; // 第 0 天持有股票，损失为买入价格

        for (int i = 1; i < n; i++) {
            // dp[i][0]：当前不持有股票，取 前一天不持有股票的利润 或 前一天持有股票并在今天卖出
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            // dp[i][1]：当前持有股票，取 前一天持有股票的利润 或 前一天不持有股票并在今天买入
            dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
        }

        return dp[n - 1][0]; // 返回最后一天不持有股票的最大利润
    }

    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println("最大利润: " + maxProfit(prices));
    }

    /**
     * 原理解释
     * 这个算法的目的是在给定的股票价格数组中，找到能够获得的最大利润。你只能进行一次买入和一次卖出。算法使用动态规划的方式来实现。
     *
     * 动态规划数组
     * dp[i][0]：表示第 i 天不持有股票的最大利润。
     * dp[i][1]：表示第 i 天持有股票的最大利润。
     * 初始化
     * dp[0][0] = 0：表示第 0 天不持有股票时的最大利润为 0。
     * dp[0][1] = -prices[0]：表示第 0 天持有股票的最大利润为负的买入价格，因为你花费了 money 来买入。
     * 状态转移
     * 对于每一天的价格 prices[i]，我们需要更新 dp[i] 的值：
     *
     * 不持有股票的最大利润：
     *
     * dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
     * 你可以选择不持有股票，这样可以选择之前不持有的利润 dp[i - 1][0]，或者选择在前一天持有并在今天卖出股票，从而获得利润 dp[i - 1][1] + prices[i]。
     * 持有股票的最大利润：
     *
     * dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])
     * 你可以选择今天再买入股票，这样你就需要从之前不持有股票的利润中减去今天的价格 dp[i - 1][0] - prices[i]，或者选择前一天仍然持有股票 dp[i - 1][1]。
     * 返回结果
     * 最后你返回最后一天不持有股票的最大利润 dp[n - 1][0]，这代表你在完成交易后能够获得的最大利润。
     *
     * 时间复杂度
     * 时间复杂度是 O(n)，因为你需要遍历给定价格数组一次。
     * 空间复杂度是 O(n)，由于使用了一个二维数组来存储每一天的利润状态。
     */
}
